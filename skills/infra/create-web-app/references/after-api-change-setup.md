# After API Change Script Reference

This script generates TypeScript DTOs and API services from the FastAPI OpenAPI schema.

## 1. Create the Script

Create `after_api_change.py` in project root:

```python
import json
import re
import subprocess
import traceback
from pathlib import Path

import requests

ROOT_DIR = Path(__file__).parent.absolute()


def snake_to_camel(snake_case_string: str) -> str:
    words = snake_case_string.split("_")
    return words[0] + "".join(word.capitalize() for word in words[1:])


def to_snake_case(other_case: str) -> str:
    return re.sub(r"(?<!^)(?=[A-Z])", "-", other_case).lower()


def normalize_name(name: str) -> str:
    if name.endswith("-Output"):
        return name[: -len("-Output")]
    elif name.endswith("-Input"):
        return name[: -len("-Input")]
    return name


def get_type(py_type: dict, schema: dict):
    if "anyOf" in py_type:
        types = []
        for i in py_type["anyOf"]:
            if "const" in i:
                types.append(i["const"])
            else:
                types.append(get_type(i, None))
        unique_types = list(set(types))

        # Sort with null and undefined always last
        def sort_types(type_name):
            if type_name in ["null", "undefined"]:
                return (1, type_name)  # Put null/undefined last
            return (0, type_name)  # Everything else first, alphabetically

        unique_types.sort(key=sort_types)
        return " | ".join(unique_types)
    if "$ref" in py_type:
        return re.findall(r"([A-Za-z0-9]*\[?\]?$)", normalize_name(py_type["$ref"]))[0]
    if "items" in py_type:
        return "Array<" + get_type(py_type["items"], schema) + ">"
    if "enum" in py_type:
        return py_type["title"]
    if "type" not in py_type:
        return "any"
    if py_type["type"] == "array":
        return "Array<" + get_type(schema["items"], schema) + ">"
    if py_type["type"] == "integer":
        return "number"
    if py_type["type"] == "dict":
        return "{[key: string]: any}"
    if py_type["type"] == "object" and "additionalProperties" in py_type:
        value = get_type(py_type["type"], schema)
        return "{[key: string]: " + value + "}"
    return py_type["type"]


def write_subs_to_url(gen_dir: Path):
    content = """
    // This file is automatically generated. Don't edit.
    // Run at repository root `uv run after_api_change.py` to re-generate this file.

    export function subsToUrl(
        url: string,
        params?: { [key: string]: string | number | boolean | null | undefined},
        queryParams?: { [key: string]: string | number | boolean | null | undefined }
    ): string {
        if (params) {
            for (const key in params) {
                if (params.hasOwnProperty(key)) {
                    const regex = new RegExp(":" + key + "($|/)");
                    url = url.replace(regex, params[key] + "$1");
                }
            }
        }
        if (queryParams) {
            const qs = Object.keys(queryParams)
            .filter((key) => queryParams[key] !== null && queryParams[key] !== undefined)
            .map((key) => {
                const value = encodeURIComponent(queryParams[key]!);
                return `${key}=${value}`;
            })
            .join("&");
            if (qs.length > 0) {
            url += "?" + qs;
            }
        }

        return url;
    }
"""

    with Path.open(gen_dir / "subs-to-url.func.ts", "w") as f:
        f.write(content)


def write_request_dedup(gen_dir: Path):
    content = """
    // This file is automatically generated. Don't edit.
    // Run at repository root `uv run after_api_change.py` to re-generate this file.

    import { Observable, shareReplay, finalize } from "rxjs";

    const IN_FLIGHT_REQUESTS = new Map<string, Observable<unknown>>();

    export function dedupGet<T>(
        url: string,
        httpCall: () => Observable<T>,
    ): Observable<T> {
        const existing = IN_FLIGHT_REQUESTS.get(url);
        if (existing) {
            return existing as Observable<T>;
        }

        const request$ = httpCall().pipe(
            shareReplay(1),
            finalize(() => IN_FLIGHT_REQUESTS.delete(url)),
        );

        IN_FLIGHT_REQUESTS.set(url, request$);
        return request$;
    }
"""

    with Path.open(gen_dir / "request-dedup.func.ts", "w") as f:
        f.write(content)


considered_dtos = set()


def generate_dtos(response: dict, gen_dir: Path):
    dto_list = [
        "// This file is automatically generated. Don't edit.",
        "// Run at repository root `uv run after_api_change.py` to re-generate this file.",
        "",
    ]
    seen_schemas = set()
    for schema in response["components"]["schemas"]:
        if schema in seen_schemas:
            raise ValueError(
                f"Duplicate schema found: {schema}. Please resolve the naming conflict in your DTOs."
            )
        seen_schemas.add(schema)

        schema_normalized_name = normalize_name(schema)
        if not schema_normalized_name.endswith(
            "DTO"
        ) and not schema_normalized_name.endswith("Enum"):
            print("Skipping", schema, "doesn't end with DTO or Enum")
            continue
        if schema_normalized_name in considered_dtos:
            print("Skipping", schema_normalized_name, "already considered")
            continue
        considered_dtos.add(schema_normalized_name)

        print("Creating DTO for", schema)
        dto = []
        if schema in ["HTTPValidationError", "ValidationError"]:
            continue
        if "properties" in response["components"]["schemas"][schema]:
            dto.append("export interface " + schema_normalized_name + "{")
            properties = []
            for property in response["components"]["schemas"][schema]["properties"]:
                type = response["components"]["schemas"][schema]["properties"][property]
                properties.append(f"{property}: {get_type(type, type)}")
            dto.extend(properties)
            dto.append("}")
            dto.append("")
        elif "enum" in response["components"]["schemas"][schema]:
            enum_values: list[str] = response["components"]["schemas"][schema]["enum"]
            enum_name = response["components"]["schemas"][schema]["title"]
            dto.append("export enum " + enum_name + " {")
            enum_values_list = []
            for key in enum_values:
                target = key
                key = key.replace("'", "")
                key = key.replace(" ", "_").upper()
                enum_values_list.append(key + '= "' + target + '",')
            dto.extend(enum_values_list)
            dto.append("}")
            dto.append("")
        # needed for enums with only 1 option
        elif (
            "const" in response["components"]["schemas"][schema]
            and "title" in response["components"]["schemas"][schema]
            and "Enum" in response["components"]["schemas"][schema]["title"]
        ):
            enum_values: list[str] = [
                response["components"]["schemas"][schema]["const"]
            ]
            enum_name = response["components"]["schemas"][schema]["title"]
            dto.append("export enum " + enum_name + " {")
            for value in enum_values:
                dto.append(value + '= "' + value + '",')
            dto.append("}")
            dto.append("")
        dto_list.append("\n".join(dto))
    dto_list.sort()
    with Path.open(gen_dir / "dto.ts", "w") as f:
        f.write("\n".join(dto_list))


def generate_interfaces(response: dict, gen_dir: Path, skip_paths: set):
    api_services: dict[str, list[str]] = {}
    for path in response["paths"]:
        if any(
            skip_path in path for skip_path in skip_paths if path.startswith(skip_path)
        ):
            print("---- Skipping", path)
            continue
        for method in response["paths"][path].keys():
            print("Generating interface for", method.ljust(6, " "), path)
            try:
                name = response["paths"][path][method]["summary"].replace(" ", "")
                if "tags" not in response["paths"][path][method]:
                    continue
                if "NoUIEndpoints" in response["paths"][path][method]["tags"]:
                    continue
                service_name = response["paths"][path][method]["tags"][0] + "ApiService"
                if service_name not in api_services:
                    api_services[service_name] = {
                        "imports": [],
                        "methods": [],
                        "has_get": False,
                    }
                if method == "get":
                    api_services[service_name]["has_get"] = True
                name = name[0].lower() + name[1:]

                parameters = []
                parameter_map = {}
                if "parameters" in response["paths"][path][method]:
                    for param in response["paths"][path][method]["parameters"]:
                        parameter_map[param["name"]] = snake_to_camel(param["name"])
                        parameter_type = get_type(param["schema"], {})
                        for splitted_param_type in parameter_type.split(" | "):
                            if splitted_param_type not in set(
                                ["string", "number", "boolean", "null", "undefined"]
                            ):
                                api_services[service_name]["imports"].append(
                                    splitted_param_type
                                )
                        parameters.append(
                            f"{parameter_map[param['name']]}: {parameter_type}"
                        )
                # We are interested in response types 200 or 201
                http_code = (
                    "200"
                    if "200" in response["paths"][path][method]["responses"]
                    else "201"
                )
                response_content = response["paths"][path][method]["responses"][
                    http_code
                ].get("content", {})

                # Handle JSON responses (DTOs)
                if "application/json" in response_content:
                    if len(response_content["application/json"]["schema"]) == 0:
                        print("No schema defined, skipping")
                        continue
                    response_type = response_content["application/json"]["schema"][
                        "$ref"
                    ].replace("#/components/schemas/", "")
                    api_services[service_name]["imports"].append(response_type)
                    http_options = ""
                # Handle binary responses (files, etc) - return as Blob
                elif (
                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    in response_content
                    or any(
                        mime_type.startswith("application/")
                        or mime_type.startswith("image/")
                        for mime_type in response_content.keys()
                    )
                ):
                    response_type = "Blob"
                    http_options = ", { responseType: 'blob' as 'json' }"
                else:
                    continue

                request_payload = ""
                if "requestBody" in response["paths"][path][method]:
                    dto_type = response["paths"][path][method]["requestBody"][
                        "content"
                    ]["application/json"]["schema"]["$ref"].replace(
                        "#/components/schemas/", ""
                    )
                    parameters.append("dto: " + dto_type)
                    api_services[service_name]["imports"].append(dto_type)
                    request_payload = ", dto"
                elif method == "post":
                    request_payload = ", {}"

                api_method = (
                    name
                    + "("
                    + ",".join(parameters)
                    + f"): Observable<{response_type}>"
                    + "{"
                )

                p = re.sub("<[a-z]*:", ":", path).replace("}", "").replace("{", ":")
                if "parameters" in response["paths"][path][method]:
                    parameters = response["paths"][path][method]["parameters"]
                    path_parameters = [
                        param["name"] for param in parameters if param["in"] == "path"
                    ]
                    query_paramters = [
                        param["name"] for param in parameters if param["in"] == "query"
                    ]
                    api_method += f'const url = subsToUrl("{p}", {{{",".join(path_parameters)}}}, {{{",".join(query_paramters)}}});'
                else:
                    api_method += f'const url = subsToUrl("{p}", {{}}, {{}});'
                for k, v in parameter_map.items():
                    api_method = api_method.replace(k, v)

                if method == "get":
                    api_method += (
                        f"return dedupGet(url, () => this.http.{method}<{response_type}>(url{http_options}));"
                        + "}\n"
                    )
                else:
                    api_method += (
                        f"return this.http.{method}<{response_type}>(url{request_payload}{http_options});"
                        + "}\n"
                    )
                api_services[service_name]["methods"].append(api_method)
            except Exception:
                print("Error generating interface for", method, path)
                print("Perhaps typing is missing")
                print(traceback.format_exc())
                print(response["paths"][path])

    index = [
        'export * from "./dto";',
        'export * from "./subs-to-url.func";',
        'export * from "./request-dedup.func";',
    ]

    for k, v in api_services.items():
        class_name = k[0].upper() + k[1:].replace("_", "")
        content = [
            "",
            '@Injectable({ providedIn: "root" })',
            f"export class {class_name} " + "{",
            "",
            "constructor(private http: HttpClient){}\n",
        ]
        v["methods"].sort()
        content.extend(v["methods"])
        content.append("}")
        imports = list(set(v["imports"]))
        imports.sort()
        base_imports = [
            'import { HttpClient } from "@angular/common/http";',
            'import { Injectable } from "@angular/core";',
            'import { Observable } from "rxjs";',
            'import { subsToUrl } from "./subs-to-url.func";',
        ]
        if v["has_get"]:
            base_imports.append('import { dedupGet } from "./request-dedup.func";')
        imports = base_imports + ["import {" + ",".join(imports) + '} from "./dto";']
        content.insert(0, "\n".join(imports))
        content.insert(0, "")
        content.insert(
            0,
            "// Run at repository root uv run after_api_change.py to re-generate this file.\n",
        )
        content.insert(0, "// This file is automatically generated. Don't edit.\n")

        file_name = (
            to_snake_case(k).replace("api-service", "api.service").replace("_", "-")
        )

        index.append(f'export * from "./{file_name}";')

        with Path.open(gen_dir / f"{file_name}.ts", "w") as f:
            f.write("\n".join(content))

    index.sort()
    with Path.open(gen_dir / "index.ts", "w") as f:
        f.write("\n".join(index))


def prettify(gen_dir: Path):
    subprocess.check_call("npx prettier *.ts --write", shell=True, cwd=str(gen_dir))


def generate_all(gen_dir: Path, open_api_url: str, skip_paths: set) -> None:
    # Remove all api__dtos__xxx_dto__ patterns from the response
    response_content = requests.get(open_api_url).content.decode("utf-8")
    response_content = re.sub(r"api__dtos__[a-zA-Z_]+_dto__", "", response_content)
    response = json.loads(response_content)

    with Path.open(ROOT_DIR / "openapi.json", "w") as f:
        json.dump(response, f, indent=2)
    generate_dtos(response, gen_dir)
    generate_interfaces(response, gen_dir, skip_paths)
    write_subs_to_url(gen_dir)
    write_request_dedup(gen_dir)
    prettify(gen_dir)


if __name__ == "__main__":
    main_app_dir = Path("src/ui/src/api-integration")
    main_app_dir.mkdir(parents=True, exist_ok=True)
    main_app_open_api_url = "http://localhost:<API_PORT>/api/openapi.json"
    path_prefixes_to_skip = set([f"/api/v1/{i}" for i in ["hello-world"]])
    generate_all(main_app_dir, main_app_open_api_url, path_prefixes_to_skip)
```

Replace `<API_PORT>` with the configured API port (e.g., 6433 or 8435).

## 2. What It Does

The script:

1. **Fetches OpenAPI schema** from the running FastAPI server
2. **Generates TypeScript DTOs** from schema definitions (interfaces and enums)
3. **Generates API service classes** with typed methods for each endpoint
4. **Creates utility functions**:
   - `subsToUrl()` - URL parameter substitution
   - `dedupGet()` - GET request deduplication
5. **Formats generated code** with Prettier

## 3. Generated Output

The script creates files in `src/ui/src/api-integration/`:

```
src/ui/src/api-integration/
├── dto.ts                    # All DTOs and enums
├── subs-to-url.func.ts       # URL helper function
├── request-dedup.func.ts     # Request deduplication
├── *-api.service.ts          # API service classes (one per tag)
└── index.ts                  # Barrel exports
```

## 4. Usage

Run after making changes to FastAPI endpoints:

```bash
# Make sure the API server is running first
uv run python start_services.py

# In another terminal, regenerate TypeScript code
uv run after_api_change.py
```

## 5. DTO Naming Convention

For DTOs to be generated, they must end with `DTO` or `Enum`:

```python
# This will be generated
class UserResponseDTO(BaseModel):
    id: str
    name: str

class StatusEnum(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"

# This will be skipped (doesn't end with DTO/Enum)
class UserModel(BaseModel):
    pass
```

## 6. API Service Generation

Services are grouped by FastAPI router tags:

```python
@router.get("/users/{user_id}", tags=["Users"])
async def get_user(user_id: str) -> UserResponseDTO:
    pass
```

Generates:

```typescript
// users-api.service.ts
@Injectable({ providedIn: "root" })
export class UsersApiService {
  constructor(private http: HttpClient) {}

  getUser(userId: string): Observable<UserResponseDTO> {
    const url = subsToUrl("/api/users/:userId", { userId }, {});
    return dedupGet(url, () => this.http.get<UserResponseDTO>(url));
  }
}
```

## 7. Skipping Endpoints

Add path prefixes to `path_prefixes_to_skip` to exclude endpoints:

```python
path_prefixes_to_skip = set([f"/api/v1/{i}" for i in ["hello-world", "internal"]])
```

Use the `NoUIEndpoints` tag to skip individual endpoints:

```python
@router.get("/internal", tags=["NoUIEndpoints"])
async def internal_endpoint():
    pass
```
