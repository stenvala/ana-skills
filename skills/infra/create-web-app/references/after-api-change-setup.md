# After API Change Script Reference

This script generates TypeScript DTOs and API services from the FastAPI OpenAPI schema.

## 1. Create the Script

Create `after_api_change.py` in project root:

```python
#!/usr/bin/env python3
"""Generate TypeScript DTOs and API services from FastAPI OpenAPI schema."""

import json
import re
import subprocess
import traceback
from pathlib import Path

import requests

ROOT_DIR = Path(__file__).parent.absolute()


def snake_to_camel(snake_case_string: str) -> str:
    words = snake_case_string.split("_")
    return words[0] + "".join(word.capitalize() for word in words[1:])


def summary_to_camel(summary: str) -> str:
    """Convert a summary like 'Update posting' to 'updatePosting'."""
    words = summary.split(" ")
    if not words:
        return summary
    return words[0].lower() + "".join(word.capitalize() for word in words[1:])


def operation_id_to_method_name(operation_id: str) -> str:
    """Extract function name from operationId and convert to camelCase.

    operationId format: update_posting_api_private_postings__posting_id__put
    Returns: updatePosting
    """
    # Split by _api_ to get the function name part
    parts = operation_id.split("_api_")
    if len(parts) < 2:
        # Fallback: use snake_to_camel on the whole thing
        return snake_to_camel(operation_id)

    function_name = parts[0]  # e.g., "update_posting"
    return snake_to_camel(function_name)


def to_snake_case(other_case: str) -> str:
    return re.sub(r"(?<!^)(?=[A-Z])", "-", other_case).lower()


def normalize_name(name: str) -> str:
    if name.endswith("-Output"):
        return name[: -len("-Output")]
    elif name.endswith("-Input"):
        return name[: -len("-Input")]
    return name


def get_type(py_type: dict, schema: dict):
    if "anyOf" in py_type:
        types = []
        for i in py_type["anyOf"]:
            if "const" in i:
                types.append(i["const"])
            else:
                types.append(get_type(i, None))
        unique_types = list(set(types))

        def sort_types(type_name):
            if type_name in ["null", "undefined"]:
                return (1, type_name)
            return (0, type_name)

        unique_types.sort(key=sort_types)
        return " | ".join(unique_types)
    if "$ref" in py_type:
        return re.findall(r"([A-Za-z0-9]*\[?\]?$)", normalize_name(py_type["$ref"]))[0]
    if "items" in py_type:
        return "Array<" + get_type(py_type["items"], schema) + ">"
    if "enum" in py_type:
        return py_type["title"]
    if "type" not in py_type:
        return "any"
    if py_type["type"] == "array":
        return "Array<" + get_type(schema["items"], schema) + ">"
    if py_type["type"] == "integer":
        return "number"
    if py_type["type"] == "dict":
        return "{[key: string]: any}"
    if py_type["type"] == "object" and "additionalProperties" in py_type:
        value = get_type(py_type["type"], schema)
        return "{[key: string]: " + value + "}"
    # Use undefined instead of null for optional TypeScript types
    if py_type["type"] == "null":
        return "undefined"
    return py_type["type"]


def write_subs_to_url(gen_dir: Path):
    content = """// This file is automatically generated. Don't edit.
// Run at repository root `uv run after_api_change.py` to re-generate this file.

export function subsToUrl(
    url: string,
    params?: { [key: string]: string | number | boolean | null | undefined},
    queryParams?: { [key: string]: string | number | boolean | null | undefined }
): string {
    if (params) {
        for (const key in params) {
            if (params.hasOwnProperty(key)) {
                const regex = new RegExp(":" + key + "($|/)");
                url = url.replace(regex, params[key] + "$1");
            }
        }
    }
    if (queryParams) {
        const qs = Object.keys(queryParams)
        .filter((key) => queryParams[key] !== null && queryParams[key] !== undefined)
        .map((key) => {
            const value = encodeURIComponent(queryParams[key]!);
            return `${key}=${value}`;
        })
        .join("&");
        if (qs.length > 0) {
        url += "?" + qs;
        }
    }

    return url;
}
"""
    with Path.open(gen_dir / "subs-to-url.func.ts", "w") as f:
        f.write(content)


def write_request_dedup(gen_dir: Path):
    content = """// This file is automatically generated. Don't edit.
// Run at repository root `uv run after_api_change.py` to re-generate this file.

import { Observable, shareReplay, finalize } from "rxjs";

const IN_FLIGHT_REQUESTS = new Map<string, Observable<unknown>>();

export function dedupGet<T>(
    url: string,
    httpCall: () => Observable<T>,
): Observable<T> {
    const existing = IN_FLIGHT_REQUESTS.get(url);
    if (existing) {
        return existing as Observable<T>;
    }

    const request$ = httpCall().pipe(
        shareReplay(1),
        finalize(() => IN_FLIGHT_REQUESTS.delete(url)),
    );

    IN_FLIGHT_REQUESTS.set(url, request$);
    return request$;
}
"""
    with Path.open(gen_dir / "request-dedup.func.ts", "w") as f:
        f.write(content)


considered_dtos = set()


def generate_dtos(response: dict, gen_dir: Path):
    dto_list = [
        "// This file is automatically generated. Don't edit.",
        "// Run at repository root `uv run after_api_change.py` to re-generate this file.",
        "",
    ]
    seen_schemas = set()
    for schema in response["components"]["schemas"]:
        if schema in seen_schemas:
            raise ValueError(
                f"Duplicate schema found: {schema}. Please resolve the naming conflict in your DTOs."
            )
        seen_schemas.add(schema)

        schema_normalized_name = normalize_name(schema)
        if not schema_normalized_name.endswith(
            "DTO"
        ) and not schema_normalized_name.endswith("Enum"):
            print("Skipping", schema, "doesn't end with DTO or Enum")
            continue
        if schema_normalized_name in considered_dtos:
            print("Skipping", schema_normalized_name, "already considered")
            continue
        considered_dtos.add(schema_normalized_name)

        dto = []
        if schema in ["HTTPValidationError", "ValidationError"]:
            continue
        if "properties" in response["components"]["schemas"][schema]:
            dto.append("export interface " + schema_normalized_name + "{")
            properties = []
            for property in response["components"]["schemas"][schema]["properties"]:
                type = response["components"]["schemas"][schema]["properties"][property]
                properties.append(f"{property}: {get_type(type, type)}")
            dto.extend(properties)
            dto.append("}")
            dto.append("")
        elif "enum" in response["components"]["schemas"][schema]:
            enum_values: list[str] = response["components"]["schemas"][schema]["enum"]
            enum_name = response["components"]["schemas"][schema]["title"]
            dto.append("export enum " + enum_name + " {")
            enum_values_list = []
            for key in enum_values:
                target = key
                key = key.replace("'", "")
                key = key.replace(" ", "_")
                key = key.replace(".", "_").upper()
                enum_values_list.append(key + '= "' + target + '",')
            dto.extend(enum_values_list)
            dto.append("}")
            dto.append("")
        elif (
            "const" in response["components"]["schemas"][schema]
            and "title" in response["components"]["schemas"][schema]
            and "Enum" in response["components"]["schemas"][schema]["title"]
        ):
            enum_values: list[str] = [
                response["components"]["schemas"][schema]["const"]
            ]
            enum_name = response["components"]["schemas"][schema]["title"]
            dto.append("export enum " + enum_name + " {")
            for value in enum_values:
                dto.append(value + '= "' + value + '",')
            dto.append("}")
            dto.append("")
        dto_list.append("\n".join(dto))
    dto_list.sort()
    with Path.open(gen_dir / "dto.ts", "w") as f:
        f.write("\n".join(dto_list))


def generate_interfaces(response: dict, gen_dir: Path, skip_paths: set):
    api_services: dict[str, list[str]] = {}
    for path in response["paths"]:
        if any(
            skip_path in path for skip_path in skip_paths if path.startswith(skip_path)
        ):
            print("---- Skipping", path)
            continue
        for method in response["paths"][path].keys():
            print("Generating interface for", method.ljust(6, " "), path)
            try:
                operation_id = response["paths"][path][method].get("operationId", "")
                name = operation_id_to_method_name(operation_id)
                if "tags" not in response["paths"][path][method]:
                    continue
                if "NoUIEndpoints" in response["paths"][path][method]["tags"]:
                    continue
                service_name = response["paths"][path][method]["tags"][0] + "ApiService"
                if service_name not in api_services:
                    api_services[service_name] = {
                        "imports": [],
                        "methods": [],
                        "has_get": False,
                    }
                if method == "get":
                    api_services[service_name]["has_get"] = True

                parameters = []
                parameter_map = {}
                if "parameters" in response["paths"][path][method]:
                    for param in response["paths"][path][method]["parameters"]:
                        # Skip header parameters (like Authorization) - handled by interceptor
                        if param.get("in") == "header" or param.get("in") == "cookie":
                            continue
                        parameter_map[param["name"]] = snake_to_camel(param["name"])
                        parameter_type = get_type(param["schema"], {})
                        for splitted_param_type in parameter_type.split(" | "):
                            if splitted_param_type not in set(
                                ["string", "number", "boolean", "null", "undefined"]
                            ):
                                api_services[service_name]["imports"].append(
                                    splitted_param_type
                                )
                        parameters.append(
                            f"{parameter_map[param['name']]}: {parameter_type}"
                        )
                # Determine HTTP status code for response
                if "200" in response["paths"][path][method]["responses"]:
                    http_code = "200"
                elif "201" in response["paths"][path][method]["responses"]:
                    http_code = "201"
                elif "204" in response["paths"][path][method]["responses"]:
                    http_code = "204"
                else:
                    print(f"Skipping {method} {path} - no supported response code")
                    continue

                response_content = response["paths"][path][method]["responses"][
                    http_code
                ].get("content", {})

                # Handle 204 No Content (void return type)
                if http_code == "204":
                    response_type = "void"
                    http_options = ""
                elif "application/json" in response_content:
                    schema = response_content["application/json"]["schema"]
                    if len(schema) == 0:
                        print("No schema defined, skipping")
                        continue
                    if "$ref" not in schema:
                        raise RuntimeError(
                            f"Endpoint {method.upper()} {path} returns a raw dict "
                            f"instead of a typed DTO. All JSON endpoints must return "
                            f"a Pydantic model (not dict). Use skill /backend-router "
                            f"to create properly typed endpoints.\n"
                            f"Schema: {schema}"
                        )
                    response_type = schema["$ref"].replace(
                        "#/components/schemas/", ""
                    )
                    api_services[service_name]["imports"].append(response_type)
                    http_options = ""
                elif (
                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    in response_content
                    or any(
                        mime_type.startswith("application/")
                        or mime_type.startswith("image/")
                        for mime_type in response_content.keys()
                    )
                ):
                    response_type = "Blob"
                    http_options = ", { responseType: 'blob' as 'json' }"
                else:
                    continue

                request_payload = ""
                is_multipart = False
                if "requestBody" in response["paths"][path][method]:
                    request_body_content = response["paths"][path][method][
                        "requestBody"
                    ]["content"]
                    if "application/json" in request_body_content:
                        dto_type = request_body_content["application/json"]["schema"][
                            "$ref"
                        ].replace("#/components/schemas/", "")
                        parameters.append("dto: " + dto_type)
                        api_services[service_name]["imports"].append(dto_type)
                        request_payload = ", dto"
                    elif "multipart/form-data" in request_body_content:
                        # File upload endpoint
                        is_multipart = True
                        parameters.append("file: File")
                        request_payload = ", formData"
                elif method in ("post", "put", "patch"):
                    request_payload = ", null"

                api_method = (
                    name
                    + "("
                    + ",".join(parameters)
                    + f"): Observable<{response_type}>"
                    + "{"
                )

                p = re.sub("<[a-z]*:", ":", path).replace("}", "").replace("{", ":")
                if "parameters" in response["paths"][path][method]:
                    parameters = response["paths"][path][method]["parameters"]
                    # Filter out header parameters and convert names to camelCase
                    path_parameters = [
                        parameter_map.get(param["name"], param["name"])
                        for param in parameters
                        if param["in"] == "path" and param.get("in") != "header"
                    ]
                    query_paramters = [
                        parameter_map.get(param["name"], param["name"])
                        for param in parameters
                        if param["in"] == "query" and param.get("in") != "header"
                    ]
                    # Also convert path template to use camelCase parameter names
                    for orig_name, camel_name in parameter_map.items():
                        p = p.replace(f":{orig_name}", f":{camel_name}")
                    api_method += f'const url = subsToUrl("{p}", {{{",".join(path_parameters)}}}, {{{",".join(query_paramters)}}});'
                else:
                    api_method += f'const url = subsToUrl("{p}", {{}}, {{}});'

                if method == "get":
                    api_method += (
                        f"return dedupGet(url, () => this.http.{method}<{response_type}>(url{http_options}));"
                        + "}\n"
                    )
                elif is_multipart:
                    # Generate FormData handling for file uploads
                    api_method += (
                        "const formData = new FormData(); formData.append('file', file);"
                        f"return this.http.{method}<{response_type}>(url{request_payload}{http_options});"
                        + "}\n"
                    )
                else:
                    api_method += (
                        f"return this.http.{method}<{response_type}>(url{request_payload}{http_options});"
                        + "}\n"
                    )
                api_services[service_name]["methods"].append(api_method)
            except RuntimeError:
                raise
            except Exception:
                print("Error generating interface for", method, path)
                print("Perhaps typing is missing")
                print(traceback.format_exc())
                print(response["paths"][path])

    index = [
        'export * from "./dto";',
        'export * from "./subs-to-url.func";',
        'export * from "./request-dedup.func";',
    ]

    for k, v in api_services.items():
        class_name = k[0].upper() + k[1:].replace("_", "")
        content = [
            "",
            '@Injectable({ providedIn: "root" })',
            f"export class {class_name} " + "{",
            "",
            "constructor(private http: HttpClient){}\n",
        ]
        v["methods"].sort()
        content.extend(v["methods"])
        content.append("}")
        imports = list(set(v["imports"]))
        imports.sort()
        base_imports = [
            'import { HttpClient } from "@angular/common/http";',
            'import { Injectable } from "@angular/core";',
            'import { Observable } from "rxjs";',
            'import { subsToUrl } from "./subs-to-url.func";',
        ]
        if v["has_get"]:
            base_imports.append('import { dedupGet } from "./request-dedup.func";')
        imports = base_imports + ["import {" + ",".join(imports) + '} from "./dto";']
        content.insert(0, "\n".join(imports))
        content.insert(0, "")
        content.insert(
            0,
            "// Run at repository root uv run after_api_change.py to re-generate this file.\n",
        )
        content.insert(0, "// This file is automatically generated. Don't edit.\n")

        file_name = (
            to_snake_case(k).replace("api-service", "api.service").replace("_", "-")
        )

        index.append(f'export * from "./{file_name}";')

        with Path.open(gen_dir / f"{file_name}.ts", "w") as f:
            f.write("\n".join(content))

    index.sort()
    with Path.open(gen_dir / "index.ts", "w") as f:
        f.write("\n".join(index))


def prettify(gen_dir: Path):
    subprocess.check_call("npx prettier *.ts --write", shell=True, cwd=str(gen_dir))


def generate_all(gen_dir: Path, open_api_url: str, skip_paths: set) -> None:
    # Try to load from local file first, fall back to URL
    response_content = requests.get(open_api_url).content.decode("utf-8")
    response_content = re.sub(r"api__dtos__[a-zA-Z_]+_dto__", "", response_content)
    response = json.loads(response_content)

    with Path.open(ROOT_DIR / "openapi.json", "w") as f:
        json.dump(response, f, indent=2)
    generate_dtos(response, gen_dir)
    generate_interfaces(response, gen_dir, skip_paths)
    write_subs_to_url(gen_dir)
    write_request_dedup(gen_dir)
    prettify(gen_dir)


if __name__ == "__main__":
    main_app_dir = Path("src/ui/src/api-integration")
    main_app_dir.mkdir(parents=True, exist_ok=True)
    main_app_open_api_url = "http://localhost:<API-PORT>/openapi.json"
    path_prefixes_to_skip = set()
    generate_all(main_app_dir, main_app_open_api_url, path_prefixes_to_skip)

```

Replace `<API_PORT>` with the configured API port (e.g., 6433 or 8435).

## 2. What It Does

The script:

1. **Fetches OpenAPI schema** from the running FastAPI server
2. **Generates TypeScript DTOs** from schema definitions (interfaces and enums)
3. **Generates API service classes** with typed methods for each endpoint
4. **Creates utility functions**:
   - `subsToUrl()` - URL parameter substitution
   - `dedupGet()` - GET request deduplication
5. **Formats generated code** with Prettier

## 3. Generated Output

The script creates files in `src/ui/src/api-integration/`:

```
src/ui/src/api-integration/
├── dto.ts                    # All DTOs and enums
├── subs-to-url.func.ts       # URL helper function
├── request-dedup.func.ts     # Request deduplication
├── *-api.service.ts          # API service classes (one per tag)
└── index.ts                  # Barrel exports
```

## 4. Usage

Run after making changes to FastAPI endpoints:

```bash
# Make sure the API server is running first
uv run python start_services.py

# In another terminal, regenerate TypeScript code
uv run after_api_change.py
```

## 5. DTO Naming Convention

For DTOs to be generated, they must end with `DTO` or `Enum`:

```python
# This will be generated
class UserResponseDTO(BaseModel):
    id: str
    name: str

class StatusEnum(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"

# This will be skipped (doesn't end with DTO/Enum)
class UserModel(BaseModel):
    pass
```

## 6. API Service Generation

Services are grouped by FastAPI router tags:

```python
@router.get("/users/{user_id}", tags=["Users"])
async def get_user(user_id: str) -> UserResponseDTO:
    pass
```

Generates:

```typescript
// users-api.service.ts
@Injectable({ providedIn: "root" })
export class UsersApiService {
  constructor(private http: HttpClient) {}

  getUser(userId: string): Observable<UserResponseDTO> {
    const url = subsToUrl("/api/users/:userId", { userId }, {});
    return dedupGet(url, () => this.http.get<UserResponseDTO>(url));
  }
}
```

## 7. Skipping Endpoints

Add path prefixes to `path_prefixes_to_skip` to exclude endpoints:

```python
path_prefixes_to_skip = set([f"/api/v1/{i}" for i in ["hello-world", "internal"]])
```

Use the `NoUIEndpoints` tag to skip individual endpoints:

```python
@router.get("/internal", tags=["NoUIEndpoints"])
async def internal_endpoint():
    pass
```
